# ADR-005: Server-Hosted Pipeline with Review-Gated Publishing Contract

**Status:** Accepted

## Context

We need to run the Agents SDK extraction pipeline on a server and make results accessible to another repository's website over HTTP.

The product workflow requires a human review step before content is published to Sanity through Chatkit. The prior shape was mostly CLI-first and tightly coupled, which made it harder to run remotely and orchestrate an approval flow from another service.

The staged changes introduce:

- Pipeline refactoring into a reusable `runPipeline` module.
- A lightweight HTTP API for async pipeline jobs and review state transitions.
- Documentation and npm scripts for server operation.

## Decision

Adopt a two-layer architecture:

1. **Reusable pipeline core** in `pipeline/runPipeline.ts` that handles query generation, search, scraping, extraction, deterministic fallback, and output artifact writing.
2. **HTTP job server** in `scripts/server.ts` that runs the pipeline asynchronously and exposes job status/results plus explicit approval/denial transitions.

Define the cross-repo integration contract as:

- This repository produces pipeline output and review status only.
- External website/Chatkit integration consumes approved output and performs Sanity writes.
- No automatic Sanity writes occur inside this server before human approval.

## Decision Drivers

- Need to run pipeline work remotely and expose results to external clients.
- Keep extraction logic reusable across CLI and server entry points.
- Enforce human-in-the-loop review before publish.
- Keep responsibility boundaries clear across repositories.

## Options Considered

### A) Keep only CLI flow

- Pros: simplest runtime model.
- Cons: not suitable for remote orchestration or review UI polling.

### B) Add HTTP wrapper around reusable pipeline core (chosen)

- Pros: supports async jobs, polling, review workflow, and external integration.
- Cons: introduces server lifecycle and API surface to maintain.

### C) Write directly to Sanity from pipeline server

- Pros: fewer hops.
- Cons: bypasses strict approval gate, couples this repo to Chatkit/Sanity credentials and publish logic.

### D) Keep Sanity writes in external website/service after approval (chosen)

- Pros: clean separation of concerns and safer publish control.
- Cons: requires stable API contract between repos.

## Consequences

### Positive

- Core pipeline logic is now reusable (`scripts/pipeline.ts` and `scripts/server.ts` both call `runPipeline`).
- Remote clients can start jobs, poll output, and record review decisions through HTTP.
- Approval is explicit (`ready_for_review` -> `approved` or `denied`) before external publish.
- Output artifacts remain file-backed for traceability (`query_file`, pipeline JSON, sanity JSON).

### Negative

- Job state is currently in-memory; server restarts lose queued/running/review state.
- API currently has no auth, rate limiting, or reviewer identity verification.
- Approval/deny endpoints capture decision state but do not yet trigger built-in callbacks/webhooks.

## Implementation Notes

- New reusable module: `pipeline/runPipeline.ts`
- CLI entry point simplified to orchestration only: `scripts/pipeline.ts`
- New HTTP server: `scripts/server.ts`
- Added npm script: `npm run server`
- Documented API and workflow in `README.md`

Job lifecycle:

- `queued`
- `running`
- `ready_for_review`
- `approved` or `denied`
- `failed`

Current API surface:

- `POST /jobs`
- `GET /jobs/:id`
- `POST /jobs/:id/approve`
- `POST /jobs/:id/deny`
- `GET /health`

## Follow-up Work

- Persist jobs to durable storage (DB/queue) for restart safety.
- Add authentication/authorization and audit metadata enforcement.
- Define webhook or event handoff for approved jobs to external Chatkit publisher.

## References

- `pipeline/runPipeline.ts`
- `scripts/server.ts`
- `scripts/pipeline.ts`
- `README.md`
