# ADR: Adopt Vitest \+ GitHub Actions CI for Testing and Quality Gates

**Status:** Accepted

## Context

This TypeScript codebase uses ESM modules and relies on browser automation (Playwright) for a scraping tool. Prior to this change, the project lacked an agreed-upon test runner and a continuous integration (CI) workflow that enforced linting, formatting, and tests on every push/PR. We needed fast feedback, good TypeScript/ESM support, simple coverage, and a CI pipeline that is easy to maintain.

## Decision Drivers

- Developer experience: fast local runs and watch mode.
- TypeScript \+ ESM compatibility with minimal config.
- Coverage support that works out of the box.
- CI integration that enforces quality gates (lint, format, tests).
- Maintainability and ecosystem maturity.

## Options Considered

**Vitest \+ GitHub Actions CI (lint, format:check, test, coverage)**  
Pros: Native Vite/ESM alignment; fast; great TS support; simple coverage via @vitest/coverage-v8; familiar Jest-like API; easy GitHub Actions setup.  
Cons: Smaller ecosystem than Jest historically.

**Jest \+ GitHub Actions CI**  
Pros: Very mature ecosystem; many guides/examples.  
Cons: More config friction with ESM/TS in 2025; slower cold starts; extra transforms/config often required.

**Do Nothing (no tests, no CI)**  
Pros: No setup time now.  
Cons: No safety net; regressions slip in; manual QA cost; inconsistent style and formatting; hard to scale.

## Decision

Adopt Vitest as the test runner with coverage, and add a GitHub Actions CI workflow that runs install, ESLint, Prettier check, and tests on every push/PR. Keep tests focused on core logic (tool runner error handling, memory behavior) and enable coverage reporting to detect gaps.

## Rationale and Trade-offs

- Vitest offers excellent ESM \+ TypeScript ergonomics and fast feedback loops, which reduces developer friction compared to Jest in an ESM-first project.
- GitHub Actions is ubiquitous, easy to maintain, and integrates cleanly with npm workflows. It gives us consistent quality gates without introducing new vendor dependencies.
- Trade-off: choosing Vitest over Jest means fewer legacy examples for some patterns, but the API parity and docs mitigate this for our scope.

## Consequences

- **Quality:** Lint/format/test run automatically; style nits and common errors get caught early. Coverage artifacts help track test depth.
- **Performance:** Fast local runs (Vitest) and predictable CI times; minor CI minutes cost on GitHub.
- **Testing:** Clear patterns for unit tests (e.g., toolRunner JSON parse hardening, memory dependency expansion). Encourages mocking external calls and keeping scraping tests light.
- **Security:** CI runs with least-privilege; secrets (e.g., OPENAI_API_KEY) are not required for unit tests. Avoid real network in CI; document that Playwright installs are explicit (npx playwright install) and not required on every CI run.
- **Operations:** Simple, maintainable workflow file; consistent checks on PRs; easier onboarding.

## **Implementation Notes**

- Test runner: Vitest with @vitest/coverage-v8.
- Scripts: npm run lint, npm run format:check, npm test, npm run coverage, npm run ci.
- Linting/Formatting: ESLint (flat config) \+ Prettier.
- Example tests: tests/toolRunner.test.ts and tests/memory.test.ts.

## **References**

- Vitest docs: [https://vitest.dev/](https://vitest.dev/)
- Coverage (v8) docs: [https://vitest.dev/guide/coverage.html](https://vitest.dev/guide/coverage.html)
- GitHub Actions (Node.js): [https://docs.github.com/actions](https://docs.github.com/actions)
- ESLint flat config: [https://eslint.org/docs/latest/use/configure/configuration-files-new](https://eslint.org/docs/latest/use/configure/configuration-files-new)
